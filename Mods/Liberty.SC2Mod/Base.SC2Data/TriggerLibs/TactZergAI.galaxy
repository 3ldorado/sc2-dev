//--------------------------------------------------------------------------------------------------
//  *** QUEEN ***
//--------------------------------------------------------------------------------------------------
fixed AIRangeQueen (int player, unit aiUnit) {
    return MaxF(AIAbilityFixed(player, c_AB_Transfusion, c_fieldRange0),
                AIAbilityFixed(player, c_AB_SpawnMutantLarva, c_fieldRange0)) + 1;
}

//--------------------------------------------------------------------------------------------------
order Transfusion (int player, unit aiUnit) {
    order ord;
    unitgroup group;
    aifilter filter;

    ord = AICreateOrder(player, c_AB_Transfusion, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return null;
    }

    group = AIFindUnits(player, null, UnitGetPosition(aiUnit), 
                        AIAbilityFixed(player, c_AB_Transfusion, c_fieldRange0) + 1,
                        c_noMaxCount)
    ;

    filter = AIFilter(player);
    AISetFilterAlliance(filter, c_playerGroupAlly);
    AISetFilterLifeLost(filter, AIEffectFixed(player, c_EF_Transfusion, c_fieldEffectChange0), c_noMax);
    group = AIGetFilterGroup(filter, group);

    return AIUnitGroupGetValidOrder(group, ord, aiUnit, c_forwards);
}

//--------------------------------------------------------------------------------------------------
order SpawnLarva (int player, unit aiUnit) {
    order ord;
    unitgroup hatcheries;
    int larvaCount;

    //  Only cast if idle.
    //
    if (UnitOrder(aiUnit, 0) != null) {
        return null;
    }

    ord = AICreateOrder(player, c_AB_SpawnMutantLarva, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return null;
    }

    //  Don't cast if we already own at least 10 larva
    //
    larvaCount = 
        TechTreeBehaviorCount(player, c_BF_MutantLarvaTimer, c_techCountQueuedOrBetter) * 4
      + TechTreeUnitCount(player, c_ZU_Larva, c_techCountQueuedOrBetter)
    ;
    if (larvaCount >= 10) {
        return null;
    }

    hatcheries = AIFindUnits(player, 
                             c_ZB_Hatchery_Alias, 
                             UnitGetPosition(aiUnit), 
                             15,
                             c_noMaxCount)
                             ;
    return AIUnitGroupGetValidOrder(hatcheries, ord, aiUnit, c_backwards);
}

//--------------------------------------------------------------------------------------------------
order CreepTumor (int player, unit aiUnit) {

    order ord;
    point p;

    //  Only cast if idle.
    //
    if (UnitOrder(aiUnit, 0) != null) {
        return null;
    }

    ord = AICreateOrder(player, c_AB_QueenBuild, 1);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return null;
    }

    //  Don't cast if there is no creep point set for this player.
    p = AIGetBestCreepSpot(player, aiUnit, 8);
    if (p == null) {
        return null;
    }

    OrderSetTargetPlacement(ord, p, aiUnit, c_ZU_CreepTumor);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return null;
    }

    return ord;
}

//--------------------------------------------------------------------------------------------------
void AIThinkQueen (int player, unit aiUnit, unitgroup scanGroup) {
    order ord;
    unit heal;

    if (AIEvalTacticalData(aiUnit, null)) {
        return;
    }
    ord = Transfusion(player, aiUnit);
    if (ord != null) {
        AICast(aiUnit, ord, c_noMarker, c_castHold);
        return;
    }
    ord = SpawnLarva(player, aiUnit);
    if (ord != null) {
        AICast(aiUnit, ord, c_noMarker, c_castHold);
        return;
    }
    ord = CreepTumor(player, aiUnit);
    if (ord != null) {
        AICast(aiUnit, ord, c_noMarker, c_castRetreat);
        return;
    }
}

//--------------------------------------------------------------------------------------------------
//  *** INFESTOR ***
//--------------------------------------------------------------------------------------------------
fixed AIRangeInfestor (int player, unit aiUnit) {
    return MaxF(AIAbilityFixed(player, c_AB_InfestedTerrans, c_fieldRange0),
                AIAbilityFixed(player, c_AB_NeuralParasite, c_fieldRange0)) + 1;

    // AIAbilityFixed(player, c_AB_UnstableMutation, c_fieldRange0)
}

//  Minimum vitality of a unit in order to mind control it,
//  infestors will mind control units > carrier.
const fixed c_neuralParasiteMinVitality = 425;

//---------------------------------------------------------------------------------------------
order NeuralParasite (int player, unit aiUnit, unitgroup scanGroup, marker mark, marker gameMark, bool lowVitality) {
    order ord;
    aifilter filter;
    unit target;

    //  vars related to nearby enemies.
    //
    aifilter groundAirFilter;
    unitgroup threatGroup;
    int enemyGroundCount;
    int enemyAirCount;
    
    //  Create order and check validity
    //
    ord = AICreateOrder(player, c_AB_NeuralParasite, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return null;
    }

    //  Scan for enemy air and ground units
    //
    enemyGroundCount = 0;
    enemyAirCount = 0;

    groundAirFilter = AIFilter(player);
    AISetFilterAlliance(groundAirFilter, c_playerGroupEnemy);
    AISetFilterPlane(groundAirFilter, c_planeGround);
    enemyGroundCount = UnitGroupCount(AIGetFilterGroup(groundAirFilter, scanGroup), c_unitCountAlive);

    AISetFilterPlane(groundAirFilter, c_planeAir);
    enemyAirCount = UnitGroupCount(AIGetFilterGroup(groundAirFilter, scanGroup), c_unitCountAlive);

    //  Apply filters to enemies
    //
    filter = AIFilter(player);
    AISetFilterAlliance(filter, c_playerGroupEnemy);
    AISetFilterBits(filter, UnitFilterStr(AIAbilityStr(player, c_AB_NeuralParasite, c_fieldTargetFiltersAB)));
    AISetFilterRange(filter, aiUnit, AIAbilityFixed(player, c_AB_NeuralParasite, c_fieldRange0) + 1);
    AISetFilterLife(filter, c_neuralParasiteMinVitality, c_noMax);
    AISetFilterMarker(filter, c_noMarkersMin, c_noMarkersMax, mark);
    AISetFilterCanAttackEnemy(filter, enemyGroundCount, enemyAirCount);
    scanGroup = AIGetFilterGroup(filter, scanGroup);

    //  Since it's a missile, we also have to check the game-side marker
    //
    filter = AIFilter(player);
    AISetFilterMarker(filter, c_noMarkersMin, c_noMarkersMax, gameMark);
    scanGroup = AIGetFilterGroup(filter, scanGroup);

    //  Return valid target
    //
    return AIUnitGroupGetValidOrder(scanGroup, ord, aiUnit, c_forwards);
}

//--------------------------------------------------------------------------------------------------
//fixed MinToCastUnstableMutation (int player) {
//    return AIAbilityFixed(player, c_AB_NeuralParasite, c_fieldEnergyCost) + 
//           AIAbilityFixed(player, c_AB_UnstableMutation, c_fieldEnergyCost);
//}
//
//order UnstableMutation (int player, unit aiUnit, unitgroup scanGroup, marker mark, bool lowVitality) {
//    order ord;
//    int energy;
//    aifilter filter;
//    unitgroup enemyCasters;
//    
//    ord = AICreateOrder(player, c_AB_UnstableMutation, 0);
//    if (!UnitOrderIsValid(aiUnit, ord)) {
//        return null;
//    }
//
//    //  Save energy for neural parasite
//    energy = UnitGetPropertyInt(aiUnit, c_unitPropEnergy, c_unitPropCurrent);
//    if (energy < MinToCastUnstableMutation(player)) {
//        return null;
//    }
//
//    //  For now, only use on enemy casters, since we want them dead and they can't attack our units.
//    filter = AIFilter(player);
//    AISetFilterBits(filter, UnitFilterStr(AIAbilityStr(player, c_AB_UnstableMutation, c_fieldTargetFiltersAB)));
//    AISetFilterAlliance(filter, c_playerGroupEnemy);
//    AISetFilterLife(filter, c_noMin, c_noMax);
//    AISetFilterMarker(filter, c_noMarkersMin, c_noMarkersMax, mark);
//    AISetFilterBehaviorCount(filter, c_noBehaviorMin, c_noBehaviorMax, c_BF_UnstableMutation);
//    enemyCasters = AIGetFilterGroup(filter, scanGroup);
//
//    enemyCasters = AIFilterCasters(enemyCasters);
//
//    return AIUnitGroupGetValidOrder(enemyCasters, ord, aiUnit, c_forwards);
//}

//---------------------------------------------------------------------------------------------
fixed MinToCastInfestedTerrans (int player) {
    return AIAbilityFixed(player, c_AB_NeuralParasite, c_fieldEnergyCost) + 
           AIAbilityFixed(player, c_AB_InfestedTerrans, c_fieldEnergyCost);
}

order InfestedTerrans (int player, unit aiUnit, unitgroup scanGroup, bool lowVitality) {
    order ord;
    int energy;
    aifilter filter;
    point castPoint;
    unit target;
    unitgroup targetGroup;  //  Don't want to modify the scanGroup... still need it for neural parasite.
    
    ord = AICreateOrder(player, c_AB_InfestedTerrans, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return null;
    }

    //  Reserve 125 mana for neural parasite
    energy = UnitGetPropertyInt(aiUnit, c_unitPropEnergy, c_unitPropCurrent);
    if (energy < MinToCastInfestedTerrans(player) && !lowVitality) {
        return null;
    }

    //  Cast on top of the weakest unit.
    //
    filter = AIFilter(player);
    AISetFilterAlliance(filter, c_playerGroupEnemy);
    AISetFilterBits(filter, UnitFilterStr(AIWeaponStr(player, c_WE_InfestedTerran, c_fieldTargetFilters)));
    AISetFilterRange(filter, aiUnit, AIAbilityFixed(player, c_AB_InfestedTerrans, c_fieldRange0) + 1);
    AISetFilterLifePercent(filter, c_noMin, c_noMax);
    targetGroup = AIGetFilterGroup(filter, scanGroup);

    //  Check for valid target
    //
    target = UnitGroupUnit(targetGroup, UnitGroupCount(targetGroup, c_unitCountAll));
    if (target == null) {
        return null;
    }
    
    castPoint = AIPlacementNearbyFindTest(player, UnitGetPosition(target), 5.0, c_ZU_InfestedTerranEgg);
    if (castPoint == c_nullPoint) {
        return null;
    }

    OrderSetTargetPoint(ord, castPoint);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return null;
    }

    return ord;
}

//---------------------------------------------------------------------------------------------
const fixed enemyMultiplierInfestor = 1.25;
const fixed minThreshold = 100.0;
const int lowVitalityPercent = 75;

void AIThinkInfestor (int player, unit aiUnit, unitgroup scanGroup) {
    //  **Infestor disease in TargetFindData.xml** Currently not in the game.
    marker mark;
    marker gameMark;
    order ord;
    unitfilter f;
    bool lowVitality;

    if (AIEvalTacticalData(aiUnit, null)) {
        return;
    }

    //  Low Vitality = less than 75%, since it takes a WHILE for the infested marines to hatch
    lowVitality = (UnitGetPropertyInt(aiUnit, c_unitPropVitalityPercent, c_unitPropCurrent) < lowVitalityPercent);
    
    //  If we outnumber the enemy, don't even bother casting any spell, unless we are less than 75%
    if (!lowVitality) {
        //  If we have greater than 1.25 * the enemies forces, we outnumber, so don't cast.
        f = UnitFilterStr("-;Missile,Dead,Stasis,Worker");
        if (AIAllyEnemyRatio(player, UnitGetPosition(aiUnit), f, AIRangeInfestor(player, aiUnit), minThreshold) > enemyMultiplierInfestor) {
            return;
        }
    }

    //  This must preserve scanGroup for Neural Parasite check.
    ord = InfestedTerrans(player, aiUnit, scanGroup, lowVitality);
    if (ord != null) {
        AICast(aiUnit, ord, c_noMarker, c_castRetreat);
    }

    //mark = AIMarker(aiUnit, c_MK_UnstableMutation);
    //ord = UnstableMutation(player, aiUnit, scanGroup, mark, lowVitality);
    //if (ord != null) {
    //    AICast(aiUnit, ord, mark, c_castRetreat);
    //    return;
    //}
    
    mark = AIMarker(aiUnit, c_MK_NeuralParasite);
    gameMark = AIMarker(aiUnit, c_MK_GameNeuralParasite);
    ord = NeuralParasite(player, aiUnit, scanGroup, mark, gameMark, lowVitality);
    if (ord != null) {
        AICast(aiUnit, ord, mark, c_castRetreat);
        return;
    }
}

//--------------------------------------------------------------------------------------------------
//  *** BANELING ***
//--------------------------------------------------------------------------------------------------
const fixed c_banelingRange = 8;
fixed AIRangeBaneling (int player, unit aiUnit) {
    return c_banelingRange;
}

//---------------------------------------------------------------------------------------------
order SapStructure (int player, unit aiUnit, unitgroup scanGroup, marker mark) {
    order ord;
    unitgroup enemyBuildingGroup;
    unitgroup enemyUnitGroup;
    unit closestEnemy;
    point banelingPosition;
    fixed distanceToEnemy;
    unit closestEnemyBuilding;
    
    bool airAllies = false;
    int damage;

    aifilter buildingFilter;
    aifilter unitFilter;

    //  Create and check the validity of order.
    //
    ord = AICreateOrder(player, c_AB_SapStructure, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return null;
    }

    //  Create non-building filter to find the closest enemy.
    //
    unitFilter = AIFilter(player);
    AISetFilterAlliance(unitFilter, c_playerGroupEnemy);
    AISetFilterBits(unitFilter, UnitFilterStr(AIEffectStr(player, c_EF_BaneUnit, c_fieldFilters)));
    AISetFilterRange(unitFilter, aiUnit, AIRangeBaneling(player, aiUnit));
    enemyUnitGroup = AIGetFilterGroup(unitFilter, scanGroup);
    
    banelingPosition = UnitGetPosition(aiUnit);
    closestEnemy = UnitGroupNearestUnit(enemyUnitGroup, banelingPosition);
    if (closestEnemy != null) {
        distanceToEnemy = DistanceBetweenPoints(banelingPosition, UnitGetPosition(closestEnemy));
    }
    else {
        distanceToEnemy = AIRangeBaneling(player, aiUnit);  //  Default distance.
    }

    //  Create building filter.
    //
    buildingFilter = AIFilter(player);
    AISetFilterAlliance(buildingFilter, c_playerGroupEnemy);
    AISetFilterBits(buildingFilter, UnitFilterStr(AIAbilityStr(player, c_AB_SapStructure, c_fieldTargetFiltersAB)));
    AISetFilterRange(buildingFilter, aiUnit, distanceToEnemy);
    damage = AIEffectInt(player, c_EF_BaneBuilding, c_fieldAmount);
    AISetFilterLifePerMarker(buildingFilter, damage, mark);
    airAllies = AINearbyPlaneTest(UnitGetPosition(aiUnit), player, AIRangeBaneling(player, aiUnit), c_planeAir, c_unitAllianceAlly);
    AISetFilterCanAttackAlly(buildingFilter, c_groundAlliesNearby, airAllies); //  Ground allies always true, since banelings are ground units.
    enemyBuildingGroup = AIGetFilterGroup(buildingFilter, scanGroup);

    closestEnemyBuilding = UnitGroupNearestUnit(enemyBuildingGroup, banelingPosition);
    if (closestEnemyBuilding == null) {
        return null;
    }

    OrderSetTargetUnit(ord, closestEnemyBuilding);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return null;
    }

    return ord;
}

//---------------------------------------------------------------------------------------------
void AIThinkBaneling (int player, unit aiUnit, unitgroup scanGroup) {
    marker mark;
    order ord;
    
    if (AIEvalTacticalData(aiUnit, null)) {
        return;
    }

    mark = AIMarker(aiUnit, c_MK_SapStructure);
    ord = SapStructure(player, aiUnit, scanGroup, mark);
    if (ord != null) {
        AICast(aiUnit, ord, mark, c_castHold);
    }
}

//--------------------------------------------------------------------------------------------------
//  *** OVERSEER ***
//--------------------------------------------------------------------------------------------------
fixed AIRangeOverseer (int player, unit aiUnit) {   
    return AIUnitFixed(player, c_ZU_Overseer, c_fieldSightDawn) + 1;

    //return MaxF(MaxF(AIAbilityFixed(player, c_AB_FungalGrowth, c_fieldRange0),
    //    AIAbilityFixed(player, c_AB_AcidSpores, c_fieldRange0)),
    //    AIAbilityFixed(player, c_AB_Changeling, c_fieldRange0)) + 1;
}

//fixed MinToCastFungalGrowth (int player) {
//    return AIAbilityFixed(player, c_AB_FungalGrowth, c_fieldEnergyCost) + 
//           AIAbilityFixed(player, c_AB_AcidSpores, c_fieldEnergyCost);
//}

//order FungalGrowth (int player, unit aiUnit, marker mark, marker gameMark, unitgroup scanGroup) {
//    order ord;
//    fixed energy;
//    aifilter filter;
//    bool groundAllies;
//    unitgroup enemyGroup;
    
//    ord = AICreateOrder(player, c_AB_FungalGrowth, 0);
//    if (!UnitOrderIsValid(aiUnit, ord)) {
//        return null;
//    }

//    //  Save energy for acid spores
//    energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergy, c_unitPropCurrent);
//    if (energy < MinToCastFungalGrowth(player)) {
//        return null;
//    }

//    
//    groundAllies = AINearbyPlaneTest(UnitGetPosition(aiUnit), player, AIRangeOverseer(player, aiUnit), c_planeGround, c_unitAllianceAlly);

//    //  Cast on strongest enemy that can attack our allies
//    filter = AIFilter(player);
//    AISetFilterBits(filter, UnitFilterStr(AIAbilityStr(player, c_AB_FungalGrowth, c_fieldTargetFiltersAB)));
//    AISetFilterCanAttackAlly(filter, groundAllies, c_airAlliesNearby);
//    AISetFilterLife(filter, c_noMin, c_noMax);
//    AISetFilterMarker(filter, c_noMarkersMin, c_noMarkersMax, mark);
//    AISetFilterBehaviorCount(filter, c_noBehaviorMin, c_noBehaviorMax, c_BF_FungalGrowth);
//    enemyGroup = AIGetFilterGroup(filter, scanGroup);
//
//    AISetFilterMarker(filter, c_noMarkersMin, c_noMarkersMax, gameMark);
//    enemyGroup = AIGetFilterGroup(filter, scanGroup);
//
//    return AIUnitGroupGetValidOrder(enemyGroup, ord, aiUnit, c_forwards);
//}

//--------------------------------------------------------------------------------------------------
//const int c_minAlliesCanAttack = 3;

//order AcidSpores (int player, unit aiUnit, unitgroup scanGroup) {
//    order ord;
//    aifilter filter;
//    bool groundEnemies;
//    bool airEnemies;
//    region r;
//    unitgroup allyGroup;
//    int allyCount;
//    point position;
//
//    ord = AICreateOrder(player, c_AB_AcidSpores, 0);
//    if (!UnitOrderIsValid(aiUnit, ord)) {
//        return null;
//    }
//
//    DebugVarInt("const", c_planeAir);
//
//    position = UnitGetPosition(aiUnit);
//    //  Only use it if we have some units that will be able to attack the enemy.
//    groundEnemies = AINearbyPlaneTest(position, player, AIRangeOverseer(player, aiUnit), c_planeGround, c_unitAllianceEnemy);
//    airEnemies = AINearbyPlaneTest(position, player, AIRangeOverseer(player, aiUnit), c_planeAir, c_unitAllianceEnemy);
//
//    //AIEffectFixed(player, c_EF_AcidSporesArea, c_fieldAreaRadius0)
//    //UnitFilterStr(AIAbilityStr(player, c_AB_AcidSpores, c_fieldTargetFiltersAB)
//    DebugVarBool("grnd", groundEnemies);
//    DebugVarBool("air", airEnemies);
//
//    r = RegionCircle(UnitGetPosition(aiUnit), AIRangeOverseer(player, aiUnit));
//    allyGroup = UnitGroupAlliance(player,
//                                  c_unitAllianceAlly,
//                                  r,
//                                  null,
//                                  c_noMaxCount)
//                                  ;
//
//    AISetFilterCanAttackAlly(filter, groundEnemies, airEnemies);
//    allyGroup = AIGetFilterGroup(filter, allyGroup);
//    allyCount = UnitGroupCount(allyGroup, c_unitCountAll);
//
//    DebugVarInt("allyCount:", allyCount);
//
//    if (allyCount < c_minAlliesCanAttack) {
//        return null;
//    }
//
//    return null;
//}

//--------------------------------------------------------------------------------------------------
//  Limit the number of enemies we check since AIPathCost could be expensive over
//  too many units.
const int c_maxEnemyCount = 5;

order Changeling (int player, unit aiUnit, unitgroup scanGroup, fixed range) {
    int enemyPlayer = -1;
    point here;
    order ord;
    point camPoint;
    fixed camDistance;

    ord = AICreateOrder(player, c_AB_Changeling, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return null;
    }

    enemyPlayer = AIGetPlayerGroup(scanGroup);
    if (enemyPlayer == -1) {
        return null;
    }

    //  A good player should be able to tell when the enemy isn't paying attention
    //  and then cast changeling.  To simulate this, the computer looks for an enemy
    //  player's camera on hard and insanse.
    //
    if (AICampSkirDiffTest(player, c_campExpert, c_skirVeryHard)) {
        camPoint = CameraGetTarget(enemyPlayer);
        here = UnitGetPosition(aiUnit);
        camDistance = DistanceBetweenPoints(camPoint, here);
        
        if (camDistance < 20) {
            return null;
        }
    }

    //  Check to see if we already have a changeling.
    if (AINearbyUnits(player, c_ZU_Changeling, here, range, 1) ||
        AINearbyUnits(player, c_ZU_ChangelingZealot, here, range, 1) ||
        AINearbyUnits(player, c_ZU_ChangelingZergling, here, range, 1) ||
        AINearbyUnits(player, c_ZU_ChangelingMarine, here, range, 1) ||
        AINearbyUnits(player, c_ZU_ChangelingZerglingWings, here, range, 1)) {
        return null;
    }

    //  Check to see if there are enough basic units around to follow.
    if ((UnitGroupCount(AIFilterPathable(AIFindUnits(enemyPlayer, c_PU_Zealot, here, range, c_maxEnemyCount), here), c_unitCountAlive) >= 2) ||
        (UnitGroupCount(AIFilterPathable(AIFindUnits(enemyPlayer, c_ZU_Zergling, here, range, c_maxEnemyCount), here), c_unitCountAlive) >= 2) ||
        (UnitGroupCount(AIFilterPathable(AIFindUnits(enemyPlayer, c_TU_Marine, here, range, c_maxEnemyCount), here), c_unitCountAlive) >= 2)) {
        return ord;
    }

    return null;
}

bool MakeChangeling (int player, unit aiUnit, unitgroup scanGroup) {
    order ord;
    unitgroup allyGroup;
    region r;
    aifilter filter;
    point position;
    bool groundEnemies;
    bool airEnemies;
    fixed range;

    if (AIIsCampaign(player)) {
        // don't auto make changlings on campaign
        return false;
    }

    //  If we already have a changeling order, ignore new orders so that 
    //  we don't cast again
    if (UnitOrderHasAbil(aiUnit, c_AB_Changeling)) {
        return false;
    }

    //  Test to see whether the overseer is scouting or fighting.
    //  For now, just test to see if there are nearby allied units that can fight the enemy.
    r = RegionCircle(UnitGetPosition(aiUnit), AIRangeOverseer(player, aiUnit));
    allyGroup = UnitGroupAlliance(player, c_unitAllianceAlly, r, null, c_noMaxCount);
    
    position = UnitGetPosition(aiUnit);
    range = AIRangeOverseer(player, aiUnit);
    groundEnemies = AINearbyPlaneTest(position, player, range, c_planeGround, c_unitAllianceEnemy);
    airEnemies = AINearbyPlaneTest(position, player, range, c_planeAir, c_unitAllianceEnemy);

    filter = AIFilter(player);
    AISetFilterCanAttackAlly(filter, groundEnemies, airEnemies);
    allyGroup = AIGetFilterGroup(filter, allyGroup);

    if (UnitGroupCount(allyGroup, c_unitCountAll) == 0) {
        ord = Changeling(player, aiUnit, scanGroup, range);
        if (ord != null) {
            AICast(aiUnit, ord, c_noMarker, c_castRetreat);
            return true;
        }
    }

    return false;
}

//--------------------------------------------------------------------------------------------------
void AIThinkOverseer (int player, unit aiUnit, unitgroup scanGroup) {
    order ord;
    marker mark;
    marker gameMark;

    if (MakeChangeling(player, aiUnit, scanGroup)) {
        return;
    }

    //gameMark = AIMarker(aiUnit, c_MK_GameFungalGrowth);
    //mark = AIMarker(aiUnit, c_MK_FungalGrowth);
    //ord = FungalGrowth(player, aiUnit, mark, gameMark, scanGroup);
    //if (ord != null) {
    //    AICast(aiUnit, ord, mark, c_castHold);
    //    return;
    //}

    //ord = AcidSpores(player, aiUnit, scanGroup);
    //if (ord != null) {
    //    AICast(aiUnit, ord, c_noMarker, c_castHold);
    //    return;
    //}

}

//--------------------------------------------------------------------------------------------------
//  *** CHANGELING ***
//--------------------------------------------------------------------------------------------------
fixed AIRangeChangeling (int player, unit aiUnit) {
    return AIUnitFixed(player, c_ZU_Overlord, c_fieldSightDawn);
}

void AIThinkChangelingUnit (int player, unit aiUnit, unitgroup scanGroup, string followUnit) {
    unitgroup followGroup;
    order ord;
    int enemyPlayer;
    region r;
    unitgroup allyGroup;
    unitgroup enemyGroup;

    if (AIIsFollowingUnit(aiUnit, followUnit)) {
        return;
    }

    //  Create a move order, and check validity
    ord = AICreateOrder(player, c_AB_Follow, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return;
    }

    r = RegionCircle(UnitGetPosition(aiUnit), AIRangeOverseer(player, aiUnit));
    enemyGroup = UnitGroupAlliance(player, c_unitAllianceEnemy, r, null, c_noMaxCount);

    enemyPlayer = AIGetPlayerGroup(enemyGroup);
    if (enemyPlayer == -1) {
        return;
    }

    //  By default, follow the provided unit type.
    followGroup = AIFindUnits(enemyPlayer, followUnit, UnitGetPosition(aiUnit), AIRangeChangeling(player, aiUnit), c_noMaxCount);
    ord = AIUnitGroupGetValidOrder(followGroup, ord, aiUnit, c_forwards);

    if (ord != null) {
        AICast(aiUnit, ord, c_noMarker, c_castHold);
        return;
    }

    //  Otherwise, find any enemy to follow.
    ord = AICreateOrder(player, c_AB_Follow, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return;
    }
    
    ord = AIUnitGroupGetValidOrder(scanGroup, ord, aiUnit, c_forwards);
    if (ord != null) {
        AICast(aiUnit, ord, c_noMarker, c_castHold);
        return;
    }

    return;
}

//--------------------------------------------------------------------------------------------------
void AIThinkChangelingZergling (int player, unit aiUnit, unitgroup scanGroup) {
    AIThinkChangelingUnit(player, aiUnit, scanGroup, c_ZU_Zergling);
}

void AIThinkChangelingMarine (int player, unit aiUnit, unitgroup scanGroup) {
    AIThinkChangelingUnit(player, aiUnit, scanGroup, c_TU_Marine);
}

void AIThinkChangelingZealot (int player, unit aiUnit, unitgroup scanGroup) {
    AIThinkChangelingUnit(player, aiUnit, scanGroup, c_PU_Zealot);
}
